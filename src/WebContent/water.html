<html>

<!--
<script src="libs\jquery.js" type="text/javascript"></script>
<script src="libs\three.js" type="text/javascript"></script>-->
<script src ="libs\gl-matrix.js" type ="text/javascript"></script>
<script src="libs\webgl-utils.js" type="text/javascript"></script>

<head>
<title>Water Shader</title>
<meta charset ="utf-8">
<meta http-equiv="X-UA-Compatible" content="chrome=1">  <!-- Use Chrome Frame in IE -->

<script id="vs_copy" type="x-shader/x-vertex">
  attribute vec2 position;
  varying vec2 f_Pos;
  void main(void)
  {
        f_Pos = position;
		//gl_Position= vec4(position*2.0-vec2(1.0), 0.0, 1.0);
		gl_Position= vec4(position, 0.0, 1.0);
  }
</script>
<script id="fs_copy" type="x-shader/x-fragment">
   precision highp float;
   varying vec2 f_Pos;
   uniform sampler2D u_info;
   uniform float u_time;

  void main(void)
  {
	vec2 texcoord = (f_Pos+vec2(1.0))*0.5;
    vec4 info = texture2D(u_info, texcoord);
	gl_FragColor = info;
  }
</script>
<script id="vs_sim" type="x-shader/x-vertex">
  precision highp float;

  attribute vec2 position;

  varying vec2 f_Pos;

  void main(void)
  {
        f_Pos = position;
		gl_Position= vec4(position, 0.0, 1.0);
  }
</script>
<script id="fs_sim" type="x-shader/x-fragment">
   precision highp float;

   uniform sampler2D u_info;
   uniform float u_time;
   varying vec2 f_Pos;

/*  bool isValid(vec2 texcoord)
  {
    if(texcoord.x<0.0) return false;
    if(texcoord.y<0.0) return false;
    if(texcoord.x>1.0) return false;
    if(texcoord.y>1.0) return false;
    return true;
  }
//  vec2 adjustTexcoord(vec2 texcoord)
//  {
//   vec2 result = texcoord;
//    if(result.x<0.0) result.x=0.0;
//    if(result.y<0.0) result.y=0.0;
//    if(result.x>1.0) result.x=1.0;
//    if(result.y>1.0) result.y=1.0;
//    return result;
//  }
  float getAverage(sampler2D samp, vec2 texcoord)
  {
//    int count = 0;
    float delta=1.0/256.0;
//    vec2 upcoord = adjustTexcoord(texcoord + vec2(0,delta));
//    vec2 downcoord =adjustTexcoord( texcoord - vec2(0,delta));
//    vec2 leftcoord = adjustTexcoord(texcoord + vec2(delta,0));
//    vec2 rightcoord =adjustTexcoord( texcoord - vec2(delta,0));

	vec2 upcoord = clamp(texcoord + vec2(0,delta), 0.0, 1.0);
    vec2 downcoord = clamp( texcoord - vec2(0,delta), 0.0, 1.0);
    vec2 leftcoord = clamp(texcoord + vec2(delta,0), 0.0, 1.0);
    vec2 rightcoord = clamp( texcoord - vec2(delta,0), 0.0, 1.0);

    float totalz=0.0;
    if(isValid(upcoord))
   		{ count+=1; totalz+=texture2D(samp,upcoord).z;}
    if(isValid(downcoord))
    	{ count+=1; totalz+=texture2D(samp,downcoord).z;}
    if(isValid(leftcoord))
    	{ count+=1; totalz+=texture2D(samp,leftcoord).z;}
    if(isValid(rightcoord))
    	{ count+=1; totalz+=texture2D(samp,rightcoord).z;}
    if(count==0) return 0.0;
    return totalz/float(count);
    
	float averageHeight = 0.0;
	averageHeight += texture2D(samp, upcoord).z;
	averageHeight += texture2D(samp, downcoord).z;
	averageHeight += texture2D(samp, leftcoord).z;
	averageHeight += texture2D(samp, rightcoord).z;
	averageHeight /= 4.0;
	return averageHeight;
	
  }*/
  void main(void)
  {

    // map to [0, 1] range
    vec2 texcoord = (f_Pos+vec2(1.0))*0.5;
	vec4 info = texture2D(u_info, texcoord);

    /*float height=0.0;
    float vel=0.0;

    if(u_time<0.015)
    {
        height = (1.0-length(f_Pos))*1.01;
    }
    else{
        vec4 waterInfo = texture2D(u_info, texcoord);
        height = waterInfo.z;
		vel = waterInfo.y;

        vel += (getAverage(u_info, texcoord) - height);
		vel *= 0.99;
        height += vel;
    }
	gl_FragColor = vec4(0,vel,height,1.0);*/

	vec2 size = vec2(2.0,0.0);

	float delta = 1.0/512.0;

	vec2 upcoord = clamp(texcoord + vec2(0.0,delta), 0.0, 1.0);
    vec2 downcoord = clamp(texcoord - vec2(0.0,delta), 0.0, 1.0);
    vec2 leftcoord = clamp(texcoord - vec2(delta,0.0), 0.0, 1.0);
    vec2 rightcoord = clamp(texcoord + vec2(delta,0.0), 0.0, 1.0);

    float s01 = texture2D(u_info, leftcoord).x;
    float s21 = texture2D(u_info, rightcoord).x;
    float s10 = texture2D(u_info, downcoord).x;
    float s12 = texture2D(u_info, rightcoord).x;

    vec3 va = normalize(vec3(size.xy,s21-s01));
    vec3 vb = normalize(vec3(size.yx,s12-s10));
    vec3 normal = cross(va,vb);

	info.z = normal.z;
	info.w = normal.x;

	gl_FragColor = info;
  }
</script>
<script id="vs_render" type="x-shader/x-vertex">
precision highp float;

  attribute vec3 position;
  attribute vec3 normal;

  uniform mat4 u_modelViewPerspective;
  uniform mat4 u_normalMatrix;
  uniform sampler2D u_info;
  uniform float u_time;
  uniform mat4 u_model;


  varying vec2 heightfieldtexcoord;
  varying float height;
  varying vec3 normal_eye;
  varying vec3 position_World;

  void main(void)
  {

		//vec2 offsetpos = position.xz*2.0-vec2(1.0);
        heightfieldtexcoord = position.zx;
        vec4 info = texture2D(u_info,heightfieldtexcoord);
		
		vec3 positionModel = vec3(position.x, info.r, position.z);
		vec3 normalModel = vec3(info.w, 1.0-info.z-info.w, info.z);

		normal_eye = normalModel;//normalize(u_normalMatrix*vec4(normalModel,0.0)).xyz;

        /*h=position.z;
        height = h;

        //use screen space
        thenormal=normalize(u_normalMatrix*vec4(normalize(normal),0.0)).xyz;
        position_World=(u_modelViewPerspective * vec4(position, 1.0)).xyz;

        //use world space
        thenormal = normalize(normal);
        position_World=(u_model*vec4(position,1.0)).xyz;*/

 		gl_Position = u_modelViewPerspective * vec4(positionModel, 1.0);
  }
</script>
<script id="fs_render" type="x-shader/x-fragment">
    precision highp float;

	varying vec2 heightfieldtexcoord;

    uniform vec3 eyePos;
    uniform sampler2D u_info;
    uniform float u_time;
    uniform mat4 u_normalMatrix;
    uniform mat4 u_modelViewPerspective;

    varying float height;
    varying vec3 normal_eye;
    varying vec3 position_World;
  void main(void)
  {
  	/*vec3 outcolor=vec3(1.0);


    vec3 light1=vec3(0.95,0.75,0.45);
    vec3 light2=vec3(92.0,162.0,206.0)/255.0;

    vec3 sunpos = vec3(0.0,-200.0,800.0);

    //use screen space
    //sunpos = (u_modelViewPerspective * vec4(sunpos, 1.0)).xyz;

    vec3 incidentdir = normalize(sunpos-position_World);

    //use screen space
    //incidentdir=normalize(u_normalMatrix*vec4(normalize(incidentdir),0.0)).xyz;

    vec3 standardnormal = normalize(thenormal);
    vec3 reflectiondir = normalize(2.0*standardnormal*dot(incidentdir,standardnormal)-incidentdir);

    vec3 eyepos = eyePos;

    //use screen space
    //eyepos = vec3(0,0,0);

    vec3 eyeraydir = normalize(eyepos-position_World);

    vec3 verticalightdir = normalize(vec3(0.0,-1.0,-1.0));

    verticalightdir = normalize(sunpos-position_World);
    //use screen space
    //verticalightdir=normalize(u_normalMatrix*vec4(normalize(verticalightdir),0.0)).xyz;

  	float specular1 = pow(max(0.01,-dot(eyeraydir,reflectiondir)),5000.0);
  	float diffuse2 = max(0.0,-dot(standardnormal,verticalightdir));

    outcolor = 3.0*specular1*light1+1.0*diffuse2*light2;*/

	
    gl_FragColor = vec4(normal_eye, 1.0);
    //gl_FragColor = vec4((thenormal+vec3(1.0))*0.5,1.0);
  }
</script>
<script id="skyboxVS" type="x-shader/x-vertex">
    precision highp float;

    attribute vec3 Position;

    uniform mat4 u_View;
    uniform mat4 u_Persp;

 	varying vec3 v_Texcoord;
    
    void main(void)
    {
        vec4 camera = u_View * vec4(Position, 1.0);
		v_Texcoord = Position;
        gl_Position = u_Persp * camera;
    }
</script>
<script id="skyboxFS" type="x-shader/x-fragment">
    precision highp float;

	uniform samplerCube u_cubeTexture;

    varying vec3 v_Texcoord;
    
    void main(void)
    {
		gl_FragColor = textureCube(u_cubeTexture, v_Texcoord);
    }    
</script>

<script src="water_mesh.js" type="text/javascript"></script>
</head>

<body onload="webGLStart();">

<p style="font-size:30px">This is WebGL water shader</p>
<div id="message" style="position:absolute;top:100px"></div> <!-- Pixel offset to avoid FPS counter -->
<div id = "debug_text"></div>
<canvas id="canvas1" style="border: none;" width="1024" height="1024" tabindex="1"></canvas>

</body>

</html>
