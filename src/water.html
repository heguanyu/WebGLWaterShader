<html>

<!--
<script src="libs\jquery.js" type="text/javascript"></script>
<script src="libs\three.js" type="text/javascript"></script>-->
<script src ="libs/gl-matrix.js" type ="text/javascript"></script>
<script src="libs/webgl-utils.js" type="text/javascript"></script>

<head>
<title>Water Shader</title>
<meta charset ="utf-8">
<meta http-equiv="X-UA-Compatible" content="chrome=1">  <!-- Use Chrome Frame in IE -->

<script id="vs_quad" type="x-shader/x-vertex">
  precision highp float;
  attribute vec2 position;
  varying vec2 f_Pos;
  void main(void)
  {
        f_Pos = position;
		gl_Position= vec4(position, 0.0, 1.0);
  }
</script>
<script id="fs_fftHorizontal" type="x-shader/x-fragment">
   precision highp float;

	vec2 complex_add(vec2 a, vec2 b)
	{
	    return vec2(a.x + b.x, a.y + b.y);
	}


	vec2 complex_mult(vec2 a, vec2 b)
	{
	    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
	}

   varying vec2 f_Pos;

   uniform sampler2D u_fftData;
   uniform sampler2D u_butterflyData;

  void main(void)
  {
	vec2 texcoord = (f_Pos+vec2(1.0))*0.5;
	vec4 indicesAndWeight = texture2D(u_butterflyData, texcoord);

	float sourceTexCoord1 = indicesAndWeight.r;
	float sourceTexcoord2 = indicesAndWeight.g;
	vec2 weight = indicesAndWeight.ba;

	vec2 source1 = texture2D(u_fftData, vec2(sourceTexCoord1, texcoord.y)).xy;
	vec2 source2 = texture2D(u_fftData, vec2(sourceTexcoord2, texcoord.y)).xy;

	vec2 result = complex_add(source1, complex_mult(source2, weight));

	gl_FragColor = vec4(result, 0.0, 1.0);
  }
</script>
<script id="fs_fftVertical" type="x-shader/x-fragment">
   precision highp float;

	vec2 complex_add(vec2 a, vec2 b)
	{
	    return vec2(a.x + b.x, a.y + b.y);
	}


	vec2 complex_mult(vec2 a, vec2 b)
	{
	    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
	}

   varying vec2 f_Pos;

   uniform sampler2D u_fftData;
   uniform sampler2D u_butterflyData; // same data as the horizontal stage

  void main(void)
  {
	vec2 texcoord = (f_Pos+vec2(1.0))*0.5;
	vec4 indicesAndWeight = texture2D(u_butterflyData, texcoord.yx); // reverse xy order to reuse the indicesAndWeight texture

	float sourceTexCoord1 = indicesAndWeight.r;
	float sourceTexcoord2 = indicesAndWeight.g;
	vec2 weight = indicesAndWeight.ba;

	vec2 source1 = texture2D(u_fftData, vec2(texcoord.x, sourceTexCoord1)).xy;
	vec2 source2 = texture2D(u_fftData, vec2(texcoord.x, sourceTexcoord2)).xy;

	vec2 result = complex_add(source1, complex_mult(source2, weight));

	gl_FragColor = vec4(result, 0.0, 1.0);
	//gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
  }
</script>
<script id="fs_copy" type="x-shader/x-fragment">
   precision highp float;
   varying vec2 f_Pos;
   uniform sampler2D u_simData;
   uniform float u_time;

  void main(void)
  {
	vec2 texcoord = (f_Pos+vec2(1.0))*0.5;
    vec4 info = texture2D(u_simData, texcoord);
	gl_FragColor = info;
  }
</script>

<script id="fs_sim" type="x-shader/x-fragment">
   precision highp float;

   uniform sampler2D u_simData;
   uniform float u_time;
   varying vec2 f_Pos;

   const float delta = 4.0/512.0;

  void main(void)
  {
    // map to [0, 1] range
    vec2 texcoord = (f_Pos+vec2(1.0))*0.5;
	vec4 info = texture2D(u_simData, texcoord);

	vec2 upcoord 	= texcoord + vec2(0.0, delta);
    vec2 downcoord  = texcoord - vec2(0.0, delta);
    vec2 leftcoord  = texcoord - vec2(delta, 0.0);
    vec2 rightcoord = texcoord + vec2(delta, 0.0);

    float s01 = texture2D(u_simData, leftcoord).x;
    float s21 = texture2D(u_simData, rightcoord).x;
    float s10 = texture2D(u_simData, downcoord).x;
    float s12 = texture2D(u_simData, upcoord).x;

    float height = info.x;
	float vel = info.y;

	// actual simulation
    vel += ((s01 + s21 + s10 + s12)*0.25 - height);
	vel *= 0.9999;
    height += vel;
	info.x = height;
	info.y = vel;

	// update normals
    vec3 va = normalize(vec3(0.0, s21-s01, 2.0*delta));
    vec3 vb = normalize(vec3(2.0*delta, s12-s10, 0.0));
    vec3 normal = normalize(cross(va, vb));

	info.wz = normal.xz;

	gl_FragColor = info;
  }
</script>
<script id="fs_simFFT" type="x-shader/x-fragment">
   precision highp float;

	vec2 conjugate(vec2 arg)
	{
	    return vec2(arg.x, -arg.y);
	}


	vec2 complex_exp(float arg)
	{
	    return vec2(cos(arg), sin(arg));
	}


	vec2 complex_add(vec2 a, vec2 b)
	{
	    return vec2(a.x + b.x, a.y + b.y);
	}


	vec2 complex_mult(vec2 a, vec2 b)
	{
	    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
	}

   uniform sampler2D u_simData;
   uniform float u_time;
   varying vec2 f_Pos;

   const float delta = 1.0/512.0;
   const float PI = 3.14159265359;

  void main(void)
  {
    // map to [0, 1] range, not perfectly aligned with texel centers???
    vec2 texcoord = (f_Pos + vec2(1.0)) * 0.5; // now center of any fragment is from vec2(-1.0 + delta/2.0) to vec2(1.0 - delta/2.0)
    vec2 texcoordMirrored = vec2(1.0) - texcoord;

	// map texcoord to [0, meshSize) range;
	vec2 n = (texcoord - vec2(delta/2.0)) * 512.0;
	// wave vector
	vec2 k = (-256.0 + n) * (2.0 * PI / 100.0);

    // calculate dispersion w(k)
    float w = sqrt(9.81 * length(k));

    vec2 h0_k = texture2D(u_simData, texcoord).xy;
    vec2 h0_mk = texture2D(u_simData, texcoordMirrored).xy;

    // output frequency-space complex values
    vec2 ht = complex_add(complex_mult(h0_k, complex_exp(w * u_time)), complex_mult(conjugate(h0_mk), complex_exp(-w * u_time)));
	//vec2 ht = complex_add(h0_k, h0_mk);
    //vec2 ht = h0_mk;

	gl_FragColor = vec4(ht, 0.0, 1.0);
  }
</script>
<script id="vs_render" type="x-shader/x-vertex">
precision highp float;

  attribute vec3 position;
  attribute vec3 normal;
  attribute vec2 texCoord;

  uniform mat4 u_model;
  uniform mat4 u_modelView;
  uniform mat4 u_modelViewPerspective;
  uniform mat4 u_normalMatrix;

  uniform sampler2D u_simData;
  uniform float u_time;

  varying vec3 normal_eye;
  varying vec3 position_eye;
  varying vec3 normal_world;
  varying vec3 position_world;


  void main(void)
  {
        vec2 heightfieldTexcoord = texCoord;
        vec4 info = texture2D(u_simData, heightfieldTexcoord);

		vec3 positionModel = vec3(position.x, sqrt(info.r*info.r + info.g*info.g), position.z);
		vec3 normalModel = vec3(info.w, sqrt(1.0- info.w*info.w - info.z*info.z), info.z);

		position_eye = (u_modelView * vec4(positionModel, 1.0)).xyz;
		//normal_eye = normalize(u_normalMatrix * vec4(normalModel, 0.0)).xyz;
		//normal_eye = normalModel;
		normal_eye = vec3(positionModel.y) ;


 		gl_Position = u_modelViewPerspective * vec4(positionModel, 1.0);
  }
</script>
<script id="fs_render" type="x-shader/x-fragment">
    precision highp float;

    uniform sampler2D u_simData;
    uniform float u_time;

	uniform mat4 u_model;
	uniform mat4 u_view;
    uniform mat4 u_persp;
	uniform mat4 u_modelViewInverse;
    uniform mat4 u_normal;
    uniform mat4 u_modelViewPerspective;

    varying vec3 normal_eye;
	varying vec3 position_eye;

  void main(void)
  {
  	/*vec3 outcolor=vec3(1.0);

    vec3 light1 = vec3(0.95,0.75,0.45);
    vec3 light2 = vec3(92.0,162.0,206.0)/255.0;

    vec3 sunpos = vec3(0.0,-200.0,800.0);

    //use screen space
    //sunpos = (u_modelViewPerspective * vec4(sunpos, 1.0)).xyz;

    vec3 incidentdir = normalize(sunpos-position_World);

    //use screen space
    //incidentdir=normalize(u_normalMatrix*vec4(normalize(incidentdir),0.0)).xyz;

    vec3 standardnormal = normalize(thenormal);
    vec3 reflectiondir = normalize(2.0*standardnormal*dot(incidentdir,standardnormal)-incidentdir);

    vec3 eyepos = eyePos;

    //use screen space
    //eyepos = vec3(0,0,0);

    vec3 eyeraydir = normalize(eyepos-position_World);

    vec3 verticalightdir = normalize(vec3(0.0,-1.0,-1.0));

    verticalightdir = normalize(sunpos-position_World);
    //use screen space
    //verticalightdir=normalize(u_normalMatrix*vec4(normalize(verticalightdir),0.0)).xyz;

  	float specular1 = pow(max(0.01,-dot(eyeraydir,reflectiondir)),5000.0);
  	float diffuse2 = max(0.0,-dot(standardnormal,verticalightdir));

    outcolor = 3.0*specular1*light1+1.0*diffuse2*light2;*/

	vec3 light = vec3(0.5, 2.0, 0.5);
	float diffuse = clamp(dot(normal_eye, (u_view * vec4(light, 1.0)).xyz - position_eye), 0.0, 1.0);

    //gl_FragColor = vec4(0.1*vec3(0.0, 0.0, 1.0) + 0.9*diffuse*vec3(0.0, 0.0, 1.0), 1.0);
    gl_FragColor = vec4(normal_eye, 1.0);
  }
</script>
<script id="fs_render_Nice" type="x-shader/x-fragment">
    precision mediump float;

	varying vec2 heightfieldtexcoord;

    uniform vec3 eyePos;
    uniform vec3 u_sunPos;
    uniform sampler2D uSampler;
    uniform float u_time;
    uniform mat4 u_modelViewPerspective_Inverse_Transpose;
    uniform mat4 u_modelViewPerspective;


    varying float height;
    varying vec3 thenormal;
    varying vec3 position_World;


    vec3 hdr (vec3 color, float exposure) {
      return 1.0 - exp(-color * exposure);
    }

  void main(void)
  {
  	vec3 outcolor=vec3(1.0);
   vec3 light1=vec3(0.95,0.75,0.45);
    vec3 light2=vec3(1.0);
    vec3 ambientcolor = vec3(93.0,96.0,255.0)/255.0;

    vec3 sunpos = u_sunPos;

    //use screen space
    //sunpos = (u_modelViewPerspective * vec4(sunpos, 1.0)).xyz;

    vec3 incidentdir = normalize(sunpos-position_World);

    //use screen space
    //incidentdir=normalize(u_modelViewPerspective_Inverse_Transpose*vec4(normalize(incidentdir),0.0)).xyz;

    vec3 standardnormal = normalize(thenormal);
    vec3 reflectiondir = normalize(2.0*standardnormal*dot(incidentdir,standardnormal)-incidentdir);

    vec3 eyepos = eyePos;

    //use screen space
    //eyepos = vec3(0,0,0);

    vec3 eyeraydir = normalize(eyepos-position_World);

    vec3 directionalLightDir = normalize(vec3(-2.0,-1.0,-2.0));
    vec3 directLight_Refelction_Dir = normalize(2.0*standardnormal*dot(directionalLightDir,standardnormal)-directionalLightDir);

    //verticalightdir = normalize(sunpos-position_World);
    //use screen space
    //verticalightdir=normalize(u_modelViewPerspective_Inverse_Transpose*vec4(normalize(verticalightdir),0.0)).xyz;

  	float specular1 = pow(max(0.01,-dot(eyeraydir,reflectiondir)),1000.0);
  	float diffuse2 =  pow(max(0.01,-dot(eyeraydir,directLight_Refelction_Dir)),10.0);

  	//float diffuse2 = max(0.0,-dot(standardnormal,verticalightdir));

    //outcolor =3.0*specular1*light1+ 1.0*diffuse2*light2+0.2*ambientcolor;


         vec3 ocean_color = vec3(0.004, 0.016, 0.047);
    vec3 sky_color = vec3(3.2, 9.6, 12.8);

     vec3 view = normalize(eyePos - position_World);

     float incidentAngle=acos(abs(dot(thenormal, view)));
     float transmittanceAngle = asin(sin(incidentAngle)/1.33);      //1.33 is the water transmittance ratio
     float temp1 = tan(incidentAngle-transmittanceAngle)/tan(incidentAngle+transmittanceAngle);
     float temp2 = sin(incidentAngle-transmittanceAngle)/sin(incidentAngle+transmittanceAngle);

     float fresnel =(temp1*temp1+temp2*temp2)*0.5;

     vec3 sky = fresnel * sky_color;

     float diffuse = clamp(dot(thenormal, directionalLightDir), 0.0, 1.0);

     vec3 water = (1.0 - fresnel) * ocean_color * sky_color * diffuse;

     outcolor = 100.0*specular1*light1 + sky + water;


    gl_FragColor = vec4(hdr(outcolor,0.35), 1.0);
  }
</script>
<!--
<script id="skyboxVS" type="x-shader/x-vertex">
    precision highp float;

    attribute vec3 Position;

    uniform mat4 u_View;
    uniform mat4 u_Persp;

 	varying vec3 v_Texcoord;

    void main(void)
    {
        vec4 camera = u_View * vec4(Position, 1.0);
		v_Texcoord = Position;
        gl_Position = u_Persp * camera;
    }
</script>
<script id="skyboxFS" type="x-shader/x-fragment">
    precision highp float;

	uniform samplerCube u_cubeTexture;

    varying vec3 v_Texcoord;

    void main(void)
    {
		gl_FragColor = textureCube(u_cubeTexture, v_Texcoord);
    }
</script>
-->

<script id="skyFS" type="x-shader/x-fragment">
precision highp float;

    uniform vec4 sky_params1;
    uniform vec4 sky_params2;
    uniform vec4 sky_params3;
    uniform vec4 sky_params4;
    uniform vec4 sky_params5;
    uniform vec4 sky_params6;

    uniform vec3 eyePos;
    uniform vec3 u_sunPos;
    uniform vec3 eyeCenter;
    uniform vec3 eyeUp;
    uniform float fov;

    varying vec2 f_Pos;

    vec3 calcExtinction(float dist) {
        return exp(dist * sky_params6.xyz);
    }

    vec3 calcScattering(float cos_theta) {
        float r_phase = (cos_theta * cos_theta) * sky_params6.w + sky_params6.w;
        float m_phase = sky_params1.w * pow(sky_params2.w * cos_theta + sky_params3.w, -1.5);
        return sky_params2.xyz * r_phase + (sky_params3.xyz * m_phase);
    }

    float baseOpticalDepth(in vec3 ray) {
        float a1 = sky_params4.x * ray.y;
        return sqrt(a1 * a1 + sky_params4.w) - a1;
    }

    float opticalDepth(in vec3 pos, in vec3 ray) {
        pos.z += sky_params4.x;
        float a0 = sky_params4.y - dot(pos, pos);
        float a1 = dot(pos, ray);
        return sqrt(a1 * a1 + a0) - a1;
    }

    vec3 get_Pixel_Dir(){
        vec3 view = normalize(eyeCenter-eyePos);
        vec3 A= cross(view,eyeUp);
        vec3 B= cross(A,view);
        vec3 M=eyePos+view;
        vec3 V=B*(length(view)*tan(fov)/length(B));
        vec3 H=-A*(length(view)*tan(fov)/length(A));
        float t1=f_Pos.x;
        float t2=f_Pos.y;
        vec3 P=M-t1*H+t2*V;
        vec3 R=normalize(P-eyePos);
        return R;
    }
    void main()
    {
        vec3 view_vec = get_Pixel_Dir();
        vec3 sun_vector = normalize(eyePos-u_sunPos);
        float cos_theta = max(dot(view_vec, sun_vector),0.0);
        float ray_dist = baseOpticalDepth(view_vec);

        vec3 extinction = calcExtinction(ray_dist);
        vec3 light_ray_pos = view_vec * (ray_dist * sky_params4.z);
        float light_ray_dist = opticalDepth(light_ray_pos, sun_vector);
        float light_ray_dist_full = opticalDepth(view_vec * ray_dist, sun_vector);
        light_ray_dist = max(light_ray_dist, light_ray_dist_full);
        vec3 incoming_light = calcExtinction(light_ray_dist*0.01);

        vec3 scattering = calcScattering(cos_theta);
        scattering *= 1.0 - extinction;

        vec3 in_scatter = incoming_light * scattering;

        float sun_strength = clamp(cos_theta * sky_params1.x + sky_params1.y, 0.0, 1.0);
        sun_strength *= sun_strength;
        vec3 sun_disk = extinction * sun_strength;
        gl_FragColor.xyz = sky_params5.xyz * (sky_params5.w * sun_disk + in_scatter);
        gl_FragColor.w = 1.0;
    }
</script>
<script src="globalVars.js" type="text/javascript"></script>
<script src="utils.js" type="text/javascript"></script>
<!--<script src="skybox.js" type="text/javascript"></script>-->
<script src="skyshader.js" type="text/javascript"></script>
<script src="firstpass.js" type="text/javascript"></script>
<script src="secondpass.js" type="text/javascript"></script>
<script src="fft.js" type="text/javascript"></script>
<script src="water_mesh.js" type="text/javascript"></script>
<script src="wave.js" type="text/javascript"></script>
</head>

<body onload="webGLStart();">

<p style="font-size:30px">This is WebGL water shader</p>
<div id="message" style="position:absolute;top:100px"></div> <!-- Pixel offset to avoid FPS counter -->
<div id = "debug_text"></div>
<canvas id="canvas1" style="border: none;" width="1024" height="1024" tabindex="1"></canvas>

</body>

</html>
